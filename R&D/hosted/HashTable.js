/**
 * Хеш-таблица (Ассоциативный массив) — абстрактный тип данных, с помощью которого хранятся пары ключ-значение. У него есть и другие названия: "словарь", "мап" (от слова map).
 * В разных языках ему соответствуют разные типы данных. В JavaScript — это Object, в других языках:
     * Ruby — Hash
     * Lua — Table
     * Python — Dictionary
     * Elixir/Java — Map
     *
 Для чего он нужен?
     * Ассоциативные массивы крайне популярны в программировании. С их помощью удобно представлять составные данные, содержащие множество различных параметров.
     * Ассоциативный массив, в отличие от обычного массива (называемого индексированным, так как значения в нем расположены по индексам), нельзя положить в память "как есть".
     * У него нет индексов, которые бы могли определить порядок и простой способ добраться до значений.
     * Для реализации ассоциативных массивов часто используют специальную структуру данных — хеш-таблицу.
     * Она позволяет организовать данные ассоциативного массива удобным для хранения способом.
     * Для этого хеш-таблица использует две вещи: индексированный массив и функцию для хеширования ключей.
     * Обратите внимание, что хеш-таблица это не просто способ размещать данные в памяти, она включает в себя логику.
 */
/**
 * Немного повторяем как работать с объектами
 */
{
    const hashTable = {}; //  В этом примере создается пустой объект, который по факту является хэш таблицей
    /**
     * Добавление элементов в хэш-таблицу происходит с помощью оператора присваивания
     * В этом примере добавляются два элемента в хэш-таблицу. Ключи элементов - ‘key1’ и ‘key2’, а значения - ‘value1’ и ‘value2’ соответственно.
     */
    hashTable['key1'] = 'value1';
    hashTable['key2'] = 'value2';

    /**
     * Для получения значения элемента из хэш-таблицы используется его ключ:
     */
    console.log(hashTable['key1']); // 'value1'

    /**
     * Удаление элементов из хэш-таблицы происходит с помощью оператора delete:
     *     В этом примере удаляется элемент хэш-таблицы с ключом ‘key2’.
     */

    delete hashTable['key2'];

    /**
     * Хэш-таблицы в JavaScript поддерживают итерацию по элементам с помощью цикла for…in:
     */
     {
         for (const key in hashTable) {
           const value = hashTable[key];
           console.log(`${key}: ${value}`);
     }

}

    /**
     * Хэш-таблицы в JavaScript могут использоваться для решения множества задач.
     * Например, они могут быть использованы для хранения данных, полученных с сервера, для кэширования результатов вычислений и т.д.
     * Пример использования хэш-таблицы для кэширования результатов функции:
     *
     */

    {
        let cache = {};

        function calculate(x) {
            if (cache[x]) {
                console.log("Using cached result");
                return cache[x];
            } else {
                console.log("Calculating result");
                let result = x * x;
                cache[x] = result;
                return result;
            }
        }

        console.log(calculate(2)); // "Calculating result", 4
        console.log(calculate(2)); // "Using cached result", 4
        console.log(calculate(3)); // "Calculating result", 9
        console.log(calculate(3)); // "Using cached result", 9
    }

/*
     * Хэш-таблицы в JavaScript имеют следующие особенности:
         * Они не гарантируют порядок элементов при итерации.
         * Ключи могут быть только строками или символами.
         * Хэш-таблицы могут использоваться для быстрого доступа к данным, поскольку операции добавления, удаления и поиска элементов выполняются за константное время в среднем случае.
         * Хэш-функция, используемая для преобразования ключей в индексы массива, должна быть хорошо распределенной, чтобы минимизировать количество коллизий (ситуации, когда два ключа имеют одинаковый хэш-код и, следовательно, указывают на один и тот же индекс массива).
*/

    /**
     * Итак, что примерно происходит, когда мы выполняем код:
     */
    {
        const data = {};
        data['key'] = 'value';
    }

}

/**
 * Хеширование
 * Любая операция внутри хеш-таблицы начинается с того, что ключ каким-то образом преобразуется в индекс обычного массива.
 * Для получения индекса из ключа нужно выполнить два действия: найти хеш (хешировать ключ) и привести его к индексу (например, через остаток от деления).
 *
 * Хеширование — операция, которая преобразует любые входные данные в строку (реже число) фиксированной длины.
 * Функция, реализующая алгоритм преобразования, называется "хеш-функцией", а результат называют "хешем" или "хеш-суммой".
 * Наиболее известны CRC32, MD5 и SHA (много разновидностей).
 */

{
    // В JavaScript нет встроенной поддержки алгоритма хеширования crc32 (удобен для наглядности)
    import crc32 from 'crc-32';

    const data = 'Hello, world!'; // Любые данные, которые мы хотим хешировать
    const hash = crc32.str(data);

    // Хеш всегда одинаковый для одних и тех же данных!
    console.log(hash); // => -337197338

    /**
     * После того, как хеш получен, его можно преобразовать в индекс массива, например, через получение остатка от деления:
     */
    const index = Math.abs(hash) % 1000; // по модулю
    console.log(index); // => 338
}

/**
 * Хэш функции
     * Хэш-функция, используемая для преобразования ключей в индексы массива, должна быть хорошо распределенной, чтобы минимизировать количество коллизий (ситуации, когда два ключа имеют одинаковый хэш-код и, следовательно, указывают на один и тот же индекс массива).
     * Хэш-функция должна быть также детерминированной, то есть при каждом вызове с одним и тем же ключом должна возвращать одинаковое значение.
     * Некоторые характеристики хорошей хэш-функции:
         * Хорошее равномерное распределение хэш-кодов по всему диапазону значений.
         * Минимизация коллизий для различных ключей.
         * Быстрое выполнение.
 */

/**
 * Полный процесс записи ключа в объект
 * Ниже это грубое описание без деталей и с упрощениями
 */
{
    // 1. Создание ассоциативного массива приводит к инициализации индексированного массива внутри интерпретатора.
    const internal = [];
        // Во время присвоения значения `data['key'] = 'value'`, интерпретатор выполняет несколько действий:
        // 2. Хеширует ключ. Результатом хеширования становится число.
            const hash = crc32.str('key'); // -337197338
        // 3. Число, полученное на предыдущем шаге, преобразуется в индекс массива.
            const index = Math.abs(hash) % 1000; // Например 3

        // В значение внутреннего индексированного массива, по найденному индексу, записывается ещё один массив,
        // первым элементом которого становится ключ `'key'`, а вторым значение `'value'`.
        internal[index] = ['key', 'value']; // [ <3 empty items>, [ 'key', 'value' ] ]. Длина массив 4
}

/**
 * Рассмотрим процесс чтения ключа
 */
{
    const data = {};
    data['key'] = 'value';
    console.log(data['key']); // => "value"

    // Для простоты показано на JavaScript, хотя в реальности всё это происходит на более низком уровне

        // 1. Хешируется ключ. Результатом хеширования становится число.
        const hash = crc32.str('key');
        // 2. Число, полученное на предыдущем шаге преобразуется в индекс массива.
        const index = Math.abs(hash % 1000);

        // 3. Если индекс существует, то извлекается массив, который находился внутри, и возвращается наружу.
        return internal[index]; // ['key', 'value']
}

/**
 * С хешированием мы встречаемся в разработке часто.
 * Например, идентификатор коммита в git 0481e0692e2501192d67d7da506c6e70ba41e913 не что иное, как хеш, полученный в результате хеширования данных коммита.
 */

/**
 * Коллизии
 * Ключом в ассоциативном массиве может быть абсолютно любая строка (любой длины и содержания). Другими словами, множество всех возможных ключей — бесконечно.
 * В свою очередь, результат любой хешируемой функции — строка фиксированной длины, а значит множество всех выходных значений — конечно.
 *
 * Из этого факта следует, что не для всех данных найдётся уникальный хеш. На каком-то этапе возможно появление дублей (когда для разных значений получается один и тот же хеш).
 * Такую ситуацию принято называть коллизией. Способов разрешения коллизий несколько, и каждому из них соответствует свой тип хеш-таблицы.
 *
 * Коллизии не так редки, как может показаться. Убедиться в этом можно, изучив парадокс дней рождений. (https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%B4%D0%BD%D0%B5%D0%B9_%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F)
 *
 * Парадо́кс дней рожде́ния — утверждение, состоящее в том, что в группе, состоящей из 23 или более человек, вероятность совпадения дней рождения (число и месяц) хотя бы у двух людей превышает 50 %.
 * Например, если в классе 23 ученика или более, то более вероятно то, что у какой-то пары одноклассников дни рождения придутся на один день, чем то, что у каждого будет свой неповторимый день рождения.
 * Для 57 и более человек вероятность такого совпадения превышает 99 %, хотя 100 % она достигает только тогда, когда в группе не менее 367 человек
 */

/**
 * Cпособы разрешения коллизий:

 * пробирование (quadratic probing) и двойное хэширование (double hashing).
 * Цепочки (Chaining) - при этом методе, в каждом индексе массива создается связанный список, в котором каждый элемент представляет собой пару “ключ-значение”. Если происходит коллизия, новый элемент добавляется в конец связанного списка.
 * Perfect hashing - это метод, при котором используется специальная хэш-функция, которая гарантирует отсутствие коллизий для данного набора ключей.
 * Robin Hood hashing - это метод, при котором при возникновении коллизии, новый элемент добавляется в ячейку, в которой уже находится другой элемент, но с меньшим расстоянием от своего идеального индекса. Это позволяет уменьшить количество перестановок элементов в массиве и ускорить поиск.
 * В общем, выбор метода решения коллизий зависит от конкретного случая и может быть определен на основе характеристик данных и использования хэш-таблицы.
 */


/**
 * При использовании метода цепочек (Chaining) в хэш-таблице, каждый элемент массива, являющегося значением ячейки хеш-таблицы, представляет собой связный список (linked list), который хранит все значения, связанные с определенным хеш-кодом ключа.
 * При добавлении элемента с одним и тем же ключом в хеш-таблицу, новый элемент добавляется в конец связного списка, соответствующего этому ключу.
 * При получении значения по ключу, происходит следующее:
 * Хеш-функция вычисляет индекс массива, соответствующий заданному ключу.
 * Если ячейка хеш-таблицы пустая, значит, элемента с таким ключом не существует в таблице, и возвращается значение undefined.
 * Если в ячейке хеш-таблицы есть элементы, то происходит проход по связному списку, связанному с заданным ключом, начиная с первого элемента. Каждый элемент списка проверяется на наличие нужного ключа.
 * Если ключ найден, возвращается соответствующее значение.
 * Если ключ не найден в текущем элементе списка, происходит переход к следующему элементу. Если список исчерпан, значит, элемента с таким ключом не существует в хеш-таблице, и возвращается значение undefined.
 * Таким образом, по умолчанию, при получении значения по ключу в хеш-таблице с использованием метода цепочек, возвращается только последнее значение в цепочке, т.е. значение последнего элемента списка, связанного с заданным ключом.
 */


/**
 * DJB2 - это простая некриптографическая хэш-функция, созданная Дэниелом Дж. Бернштейн (собственно отсюда и название функции - инициалы автора).
 * Он используется для различных целей, таких как индексация, поиск и сравнение данных.
 * Эта функция используется для создания уникального значения для каждой строки, которое может быть использовано в качестве ключа в хэш-таблице
 * // TODO: привести конкретные примеры для использования (https://thestrangeadventurer.com/hesh-funkciya-djb2/)
 */
{
    function djb2Hash(str) {
        let hash = 5381;
        for (let i = 0; i < str.length; i++) {
            const charCode = str.charCodeAt(i);
            hash = ((hash << 5) + hash) + charCode;
        }
        return hash;
    }
}

/**
 * В качестве начального значения хеша выбрано простое число 5381, число выбрано самим Бернштейном.
 * Почему 5381 ?
     *  Дэн Бернштейн, автор алгоритма DJB2, выбрал число 5381 в качестве начального значения хэша после ряда экспериментов, которые он провел на различных наборах данных.
     *  Он обнаружил, что это число хорошо работает в большинстве случаев, и выбрал его в качестве стандартного начального значения для алгоритма DJB2. Также он заметил, что это число имеет определенные свойства, которые делают его подходящим для использования в алгоритме хэширования, так как оно:
     *  Нечетное, что гарантирует, что ни один бит не будет установлен в нуль.
     *  Не слишком большое и не слишком маленькое, что помогает достичь баланса между скоростью вычислений и качеством хэширования.
     *  Имеет много различных битовых комбинаций, что позволяет алгоритму создавать большое количество различных хэш-значений для различных входных данных.
     *  Несмотря на то, что число 5381 может показаться случайным, оно было выбрано Бернштейном из-за его особенностей и эффективности в контексте алгоритма DJB2.
 *
 * Простые числа часто используются в хеш-функциях, потому что они, как правило, дают более равномерное распределение хэш-значений.
 *
 * Еще из интересного ((hash << 5) + hash) - эквивалетно умножению hash на 33. Но почему именно 33?
 *
 * Автор функции, экспериментировал с различными значениями множителя и обнаружил, что 33 дали хорошие результаты с точки зрения минимизации коллизий и создания равномерного распределения хэш-значений.
 * В частности, он обнаружил, что 33 хорошо работают в сочетании с побитовым левым сдвигом (<< 5), который используется в алгоритме DJB2, то есть число по сути подобрано эмперически(опытнам путем).
 */

/**
 * Хэш-функции могут быть различными в зависимости от типа ключей, используемых в структуре данных.
 * Например, для чисел может использоваться простая операция деления, а для объектов - преобразование объекта в строку и использование хэш-функции для строк.
 */

/**
 * TODO написать функцию, которая будет через интервал присылать строчки, и функция хэширования будет их преборазовавывать и сравнивать
 */
{
    const hashTable = {};

    function addToHashTable(key, value) {
        const hashKey = djb2Hash(key);
        hashTable[hashKey] = value;
    }

    addToHashTable('name', 'John Doe');
}




