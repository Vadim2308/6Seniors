/**
 * По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы.
 * Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.
 * «Символ» представляет собой уникальный идентификатор.
 */
{
    // Создаём символ id с описанием (именем) "id"
    let id = Symbol("id");

    // Символы гарантированно уникальны.
    let id1 = Symbol("id");
    let id2 = Symbol("id");
    alert(id1 === id2); // false
}
{
    /**
     * Cимволы не преобразуются автоматически к строке, это своеобразная защита
     */
    let id = Symbol("id");
    alert(id); // TypeError: Cannot convert a Symbol value to a string

    // Мы можем сами, явно преобразовать символ к строке
    alert(id.toString()); // Symbol(id), теперь работает

    // Или мы можем обратиться к свойству symbol.description, чтобы вывести только описание:
    alert(id.description); // id
}

/**
 * «Скрытые» свойства
 * Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.
 */
{
    let user = {
        name: "Вася"
    };

    let id = Symbol("id");
    user[id] = 1;
    alert( user[id] ); // мы можем получить доступ к данным по ключу-символу, однако если мы законсолим user, то там будет {name: "Вася"};
}
{
    let id = Symbol("id");
    let user = {
        name: "Вася",
        [id]: 123 // просто "id: 123" не сработает
    };
}

/**
 * Символы игнорируются циклом for…in и Object.keys(user), но копируются при Object.assign,{...user}
 * НЕ копируются при методе JSON.parse(JSON.stringify(user));
 */
{
    let id = Symbol("id");
    let user = {
        name: "Вася",
        age: 30,
        [id]: 123
    };
    for (let key in user) alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)
    // хотя прямой доступ по символу работает
    alert( "Напрямую: " + user[id] );
}

/**
 * Глобальные символы
 * Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.
 */
{
    // читаем символ из глобального реестра и записываем его в переменную
    let id = Symbol.for("id"); // если символа не существует, он будет создан

    // читаем его снова и записываем в другую переменную (возможно, из другого места кода)
    let idAgain = Symbol.for("id");

    // проверяем -- это один и тот же символ
    alert( id === idAgain ); // true
}
/**
 * Symbol.keyFor
 * Для глобальных символов, кроме Symbol.for(key), который ищет символ по имени, существует обратный метод:
 * Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя
 */
{
    // получаем символ по имени
    let sym = Symbol.for("name");
    let sym2 = Symbol.for("id");

    // получаем имя по названию переменной
    alert( Symbol.keyFor(sym) ); // name
    alert( Symbol.keyFor(sym2) ); // id

    {
        // Работает только с символами, созданные через .for. С неглоабльными вернет undefined
        let globalSymbol = Symbol.for("name");
        let localSymbol = Symbol("name");

        alert(Symbol.keyFor(globalSymbol)); // name, глобальный символ
        alert(Symbol.keyFor(localSymbol)); // undefined для неглобального символа

        alert(localSymbol.description); // name
    }
}

/**
 * Внутри самого объекта существует много символов, и с помощью них можно например настраивать поведение объектов
 * В частности, Symbol.toPrimitive (он лежит в каждом объекте) позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву.
 * Symbol.iterator, который позволяет реализовать обход конструкции с помощью синтаксических конструкций for..of (по умолчанию он недоступен для объектов)
 */
{
    const object1 = {
        [Symbol.toPrimitive](hint){
            // hint string || number || default
            if (hint === 'number') {
                return 42; // При дефолтном преобразовании объекта (Number({}) => NaN). Но мы можем это изменить. Number(object) === 42
            }
            return null;
        }
    };
    // https://www.youtube.com/watch?v=vgB5eNMvXBk&t=2s
    // https://www.youtube.com/watch?v=Eig7jYk22LI
}

/**
 * P.S.
 * Технически символы скрыты не на 100%. Существует встроенный метод Object.getOwnPropertySymbols(obj) – с его помощью можно получить все свойства объекта с ключами-символами.
 * Также существует метод Reflect.ownKeys(obj), который возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны.
 * Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.
 */