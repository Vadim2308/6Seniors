/**
 * В случае obj1 + obj2 || obj1 - obj2 происходит преобразование объектов к примитиву, поэтому результатом таких операций не может быть другой объект
 * 1. Все объекты к приведению к булевому типу (Boolean({})) дают true
 * 2. Существует лишь их числовое и строковое преобразование.
 * 3. Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции
 * 4. Преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.
 */

/**
 * Хинты
 * Существует три варианта преобразования типов, которые происходят в различных ситуациях. "string" || "number" || "default"
 */
{
    // "string" Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:
    // вывод
    alert(obj); //[object Object]
    // используем объект в качестве ключа
    anotherObj[obj] = 123;
}
{
    // "number". Для преобразования объекта к числу, в случае математических операций:

    // явное преобразование
    let num = Number(obj);
   // математические (не считая бинарного плюса)
    let n = +obj; // унарный плюс
    let delta = date1 - date2;
    // сравнения больше/меньше
    let greater = user1 > user2;
}
{
    // "default"
    /**
     * Происходит редко, когда оператор «не уверен», какой тип ожидать.
     * Например, бинарный плюс + может работать как со строками (объединяя их в одну), так и с числами (складывая их).
     * Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для его преобразования.
     * Также, если объект сравнивается с помощью == со строкой, числом или символом, тоже неясно, какое преобразование следует выполнить, поэтому используется хинт "default".
     */
}
{
    // бинарный плюс использует хинт "default"
    let total = obj1 + obj2; // [object Object][object Object]
    // obj == number использует хинт "default"
    if (user == 1) { ... };
}

/**
 * Операторы сравнения больше/меньше, такие как < >, также могут работать как со строками, так и с числами.
 * Тем не менее, по историческим причинам, они используют хинт "number", а не "default".
 */

{
    const object1 = {
        [Symbol.toPrimitive](hint){
            // hint string || number || default
            if (hint === 'number') {
                return 42; // При дефолтном преобразовании объекта (Number({}) => NaN). Но мы можем это изменить. Number(object) === 42
            }
            if (hint === 'string') {
                return 'hint string'; // При преобразовании объекта к строке. String(object1) || alert(object) || someobj[object1]
            }
            return null;
        }
    };
    // https://www.youtube.com/watch?v=vgB5eNMvXBk&t=2s
    // https://www.youtube.com/watch?v=Eig7jYk22LI
}

/**
 * toString/valueOf
 * Для хинта "string": вызвать метод toString, а если он не существует или возвращает объект вместо примитивного значения, то valueOf
 * Для других хинтов: вызвать метод valueOf, а если он не существует или возвращает объект вместо примитивного значения, то toString
 */

{
    // Пример без перезаписи методов
    let user = {
        name: "John",
        money: 1000,
    };
    console.log(String(user)); // String(user). 1. toString() => [object Object]
    console.log(+user); // Приводим к числу. 1. valueOf() => вернет объект user. Т.к. это не примитив, вызовется toString() => Number([object Object]) => NaN
    console.log(user + 500); // hint === default. valueOf() => вернет объект user. Т.к. это не примитив, вызовется toString() и вернет [object Object]. '[object Object]' + 500 === '[object Object]500'
}
    // Пример с перезаписью методов
{
    let user = {
        name: "John",
        money: 1000,
        // для хинта равного "string"
        toString() {
            return `{name: "${this.name}"}`;
        },
        // для хинта равного "number" или "default"
        valueOf() {
            return this.money;
        }

    };
    console.log(String(user)); // toString -> {name: "John"}
    console.log(+user); // valueOf -> 1000
    console.log(user + 500); // valueOf -> 1500
}
{
    let user = {
        name: "John",
        toString() {
            return this.name;
        }
    };
    alert(user); // toString -> John
    alert(user + 500); // valueOf() => user => toString -> John500
}

/**
 * Дальнейшие преобразования
 * Если мы передаём объект в качестве аргумента, то в вычислениях будут две стадии:
 * 1 Объект преобразуется в примитив (с использованием правил, описанных выше).
 * 2 Если необходимо для дальнейших вычислений, этот примитив преобразуется дальше.
 */
{
    let obj = {
        // toString обрабатывает все преобразования в случае отсутствия других методов
        toString() {
            return "2";
        }
    };
    alert(obj * 2); // 4, объект был преобразован к примитиву "2", затем умножение сделало его числом
    /**
     * Умножение obj * 2 сначала преобразует объект в примитив (это строка "2").
     * Затем "2" * 2 становится 2 * 2 (строка преобразуется в число).
     */
}
{
    let obj = {
        toString() {
            return "2";
        }
    };
    alert(obj + 2); // 22 ("2" + 2), преобразование к примитиву вернуло строку => конкатенация
}
/**
 * Алгоритм преобразования таков:
 * Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует,
 * В случае, если хинт равен "string" происходит попытка вызвать obj.toString() и obj.valueOf(), смотря что есть.
 * В случае, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf() и obj.toString(), смотря что есть.
 */