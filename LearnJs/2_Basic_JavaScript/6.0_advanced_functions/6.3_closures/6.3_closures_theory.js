/**
 * Лексическое Окружение
 * В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.
 * Мы не можем получить его в нашем коде и изменять напрямую
 * Объект лексического окружения (LexicalEnvironment) состоит из двух частей:
 *   1. Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this). Или по другому локальное лексическое окружение
 *   2. [[Environment]] Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).
 *
 */

/**
 * Function Declaration
 * В отличие от переменных, объявленных с помощью let, они полностью инициализируются не тогда, когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение! Т.е. хостятся наверх
 * Вот почему мы можем вызвать функцию, объявленную через Function Declaration, до того, как она определена.
 */

/**
 * Внутреннее и внешнее лексическое окружение
 * Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.
 *
 * Если переменная не была найдена, это будет ошибкой в strict mode.
 * Без strict mode, для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем
 */

/**
 * Функция получает текущее значение внешних переменных, то есть их последнее значение
 *
 * Один вызов – одно лексическое окружение
 * Если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение
 */
{
    let name = "John";
    function sayHi() {
        alert("Hi, " + name);
    }
    name = "Pete"; // (*)
    sayHi(); // Pete
}

/**
 * count – локальная переменная функции, мы не можем получить к ней доступ извне.
 */
{
    function makeCounter() {
        let count = 0;

        return function() {
            return count++; // есть доступ к внешней переменной "count"
        };
    }
    let counter = makeCounter();
    alert( counter() ); // 0
    alert( counter() ); // 1
    alert( counter() ); // 2
}

/**
 * Для каждого вызова makeCounter() создаётся новое лексическое окружение функции, со своим собственным count. Так что получившиеся функции counter – независимы.
 */
{
    function makeCounter() {
        let count = 0;
        return function() {
            return count++;
        };
    }

    let counter1 = makeCounter();
    let counter2 = makeCounter();

    alert( counter1() ); // 0
    alert( counter1() ); // 1

    alert( counter2() ); // 0 (независимо)
}

/**
 * Детальный разбор счетчика makeCounter
 *
 *      1. Когда скрипт только начинает выполняться, есть только глобальное лексическое окружение.
 *      1.1. Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы.
 *      1.2. makeCounter создан в глобальном лексическом окружении, так что [[Environment]] содержит ссылку на него.
 *      1.3. [[Environment]] – скрытое свойство функции, которое содержит эту ссылку. Функция навсегда запоминает ссылку на лексическое окружение, где она была создана
 *
 *      2. Код продолжает выполняться, объявляется новая глобальная переменная counter, которой присваивается результат вызова makeCounter.
 *      2.1 В момент вызова makeCounter() создаётся лексическое окружение, для хранения его переменных и аргументов, а именно
 *          Environment Record с локальными переменными.
 *          Ссылка на внешнее окружение, которая устанавливается в значение [[Environment]] функции
 *
 *      3 При вызове counter() для этого вызова создаётся новое лексическое окружение.
 *      3.1 Оно пустое, так как в самом counter локальных переменных нет.
 *          Environment Record - пустое.
 *          [[Environment]] - ссылка на внешнее л.о.
 */

/**
 * Лексические окружения остаются в памяти, пока есть функции, которые могут его использовать.
 * И только тогда, когда таких не остаётся, окружение уничтожается.
 */


/**
 * Блоки кода и циклы, IIFE
 * Лексическое окружение существует для любых блоков кода {...}.
 */
{
    let phrase = 'Hello'
    if(true){
        let user = 'John'
        console.log(`${phrase} ${user}`)
    }
    console.log(user) // Error

    /**
     * Когда выполнение попадает в блок if, для этого блока создаётся новое лексическое окружение.
     * У него есть ссылка на внешнее окружение, так что phrase может быть найдена.
     */
}

/**
 * For, while
 * Для цикла у каждой итерации своё отдельное лексическое окружение. Если переменная объявлена в for(let ...), то она также в нём
 *
 * Конструкция for – особенная, у каждой итерации цикла своё собственное лексическое окружение с текущим i в нём.
 */
{
    for (let i = 0; i < 10; i++) {
        // У каждой итерации цикла своё собственное лексическое окружение
        // {i: value}
    }
    alert(i); // Ошибка, нет такой переменной
}

/**
 * Блоки кода
 * Мы также можем использовать «простые» блоки кода {...}, чтобы изолировать переменные в «локальной области видимости».
 */

/**
 * IIFE (immediately-invoked function expressions) -  функция, запускаемая сразу после объявления
 */
{
    (function() {
        let message = "Hello";
        alert(message); // Hello
    })();
}
/**
 * Function Expression обёрнуто в скобки (function {...}), потому что, когда JavaScript встречает "function",он воспринимает это как начало Function Declaration.
 * Но у Function Declaration должно быть имя
 */
{
    function() { // <-- Error: Unexpected token (
        let message = "Hello";
        alert(message); // Hello
    }()
}
/**
 * даже если добавим скобки
 */
{
    // ошибка синтаксиса из-за скобок ниже
    function go() {
    }(); // <-- не можете вызывать Function Declaration немедленно
}

/**
 * Пути создания IIFE
 */
{
    (function() {
        alert("Скобки вокруг функции");
    })();

    (function() {
        alert("Скобки вокруг всего");
    }());

    !function() {
        alert("Выражение начинается с логического оператора NOT");
    }();

    +function() {
        alert("Выражение начинается с унарного плюса");
    }();
}

/**
 * Сборка мусора
 * Обычно лексическое окружение очищается и удаляется после того, как функция выполнилась.
 */
{
    function f() {
        let value1 = 123;
        let value2 = 456;
    }
    f();
}
/**
 * Но, если есть вложенная функция, которая всё ещё доступна после выполнения f, то у неё есть свойство [[Environment]], которое ссылается на внешнее лексическое окружение, тем самым оставляя его достижимым, «живым»
 */
{
    function f() {
        let value = 123;
        function g() { alert(value); }
        return g;
    }
    let g = f(); // g доступно и продолжает держать внешнее лексическое окружение в памяти
}

/**
 * Объект лексического окружения умирает, когда становится недоступным (как и любой другой объект).
 * Другими словами, он существует только до того момента, пока есть хотя бы одна вложенная функция, которая ссылается на него.

 * После того как g станет недоступным, лексическое окружение функции (и, соответственно, value) будет удалено из памяти:
 */
{
    function f() {
        let value = 123;
        function g() { alert(value); }
        return g;
    }
    let g = f(); // пока g существует, соответствующее лексическое окружение существует
    g = null; // ...а теперь память очищается
}

/**
 * /**
 *  * Замыкание
 *  * Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена.
 *  * Другими словами, замыкание даёт вам доступ к Scope внешней функции из внутренней функции.
 *  * В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
 *  */

/**
 * Если ли разница между [[Environment]] и [[Scopes]]
 *
 * Да, существует разница между [[Environment]] и [[Scopes]]
 *
 * [[Environment]] - это внутренняя свойство объекта функции в JavaScript, которое содержит ссылку на лексическое окружение, в котором была создана функция.
 *
 * [[Scopes]] - это объект, в котором содержатся все переменные, определенные в этом блоке кода. Если есть функции в блоке, т они также имеют свой [[Scopes]], в котором лежат переменные, объявленные внутри функции и ссылка на саму себя.
 * Если переменная была определена внутри функции, то ссылка на лексическое окружение этой функции будет сохранена в [[Scopes]] переменной.
 *
 * Таким образом, основная разница между [[Environment]] и [[Scopes]] заключается в том, что первое относится к функциям, а второе - к переменным.
 * [[Environment]] связано с лексическим окружением функции, в то время как [[Scopes]] связано с лексическим окружением переменной.
 */