{
    let promise = fetch(url, {
        method: "GET", // POST, PUT, DELETE, etc.
        headers: {
            // значение этого заголовка обычно ставится автоматически,
            // в зависимости от тела запроса
            "Content-Type": "text/plain;charset=UTF-8"
        },
        body: undefined, // string, FormData, Blob, BufferSource или URLSearchParams
        referrer: "about:client", // или "" для того, чтобы не послать заголовок Referer,
        // или URL с текущего источника
        referrerPolicy: "strict-origin-when-cross-origin", // no-referrer-when-downgrade, no-referrer, origin, same-origin...
        mode: "cors", // same-origin, no-cors
        credentials: "same-origin", // omit, include
        cache: "default", // no-store, reload, no-cache, force-cache или only-if-cached
        redirect: "follow", // manual, error
        integrity: "", // контрольная сумма, например "sha256-abcdef1234567890"
        keepalive: false, // true
        signal: undefined, // AbortController, чтобы прервать запрос
        window: window // null
    });
}

/**
 * Referer Policy
 * Необязательный параметр, можно установить любой реферер в пределах источника или же убрать его
 * Подробноая таблица на learn.js
  */
{
    fetch('/page', {
        // предположим, что мы находимся на странице https://javascript.info
        // мы можем установить любое значение Referer при условии, что оно принадлежит текущему источнику
        referrer: "https://javascript.info/anotherpage"
    });
}
/**
 * Допустим, у нас есть админка со структурой URL, которая не должна стать известной снаружи сайта.
 * Если мы отправляем запрос fetch, то по умолчанию он всегда отправляет заголовок Referer с полным URL-адресом Например, Referer: https://javascript.info/admin/secret/paths
 */
{
    fetch('https://another.com/page', {
        referrerPolicy: "origin-when-cross-origin" // Referer: https://javascript.info вместо https://javascript.info/admin/secret/paths
    });
}

/**
 * mode это защита от нечаянной отправки запроса на другой источник
 * По умолчанию стоит "cors"
 * "same-origin" – запросы на другой источник запрещены,
 * "no-cors" – разрешены только простые запросы на другой источник.
 */

/**
 * credentials
 * credentials указывает, должен ли fetch отправлять куки и авторизационные заголовки HTTP вместе с запросом.
 *
 * "same-origin" – стоит по умолчанию, не отправлять для запросов на другой источник,
 * "include" – отправлять всегда, но при этом необходим заголовок Access-Control-Allow-Credentials в ответе от сервера
 * "omit" – не отправлять ни при каких обстоятельствах, даже для запросов, сделанных в пределах текущего источника.
 */

/**
 * cache
 * Настройка cache позволяет игнорировать HTTP-кеш или же настроить его использование:
 *
 * "default" – fetch будет использовать стандартные правила и заголовки HTTP кеширования,
 * "no-store" – полностью игнорировать HTTP-кеш, этот режим становится режимом по умолчанию, если присутствуют такие заголовки как If-Modified-Since, If-None-Match, If-Unmodified-Since, If-Match, или If-Range,
 * "reload" – не брать результат из HTTP-кеша (даже при его присутствии), но сохранить ответ в кеше (если это дозволено заголовками ответа);
 * "no-cache" – если существует кешированный ответ – создать условный запрос, в противном же случае – обычный запрос. Сохранить ответ в HTTP-кеше,
 * "force-cache" – использовать ответ из HTTP-кеша, даже если он устаревший. Если же ответ в HTTP-кеше отсутствует, сделать обычный HTTP-запрос, действовать как обычно,
 * "only-if-cached" – использовать ответ из HTTP-кеша, даже если он устаревший. Если же ответ в HTTP-кеше отсутствует, то выдаётся ошибка. Это работает, только когда mode установлен в "same-origin".
 */

/**
 * redirect
 * "follow" – стоит по умолчанию, следовать HTTP-редиректам,
 * "error" – ошибка в случае HTTP-редиректа,
 * "manual" – не следовать HTTP-редиректу, но установить адрес редиректа в response.url, а response.redirected будет иметь значение true, чтобы мы могли сделать перенаправление на новый адрес вручную.
 */

/**
 * integrity
 * Опция integrity позволяет проверить, соответствует ли ответ известной заранее контрольной сумме.
 * Атрибут, который может быть использован в функции для проверки целостности загружаемого ресурса. Он позволяет убедиться, что загружаемый файл не был изменен или поврежден в процессе передачи.
 * При загрузке ресурса, браузер вычисляет хеш-сумму загруженного файла и сравнивает ее с указанной в атрибуте integrity.
 * Если значения не совпадают, браузер считает загруженный ресурс недействительным и отклоняет его.
 *
 * Использование атрибута integrity в fetch() особенно полезно при загрузке внешних скриптов или библиотек, так как это помогает предотвратить атаки типа "внедрение злонамеренного кода" или обнаружить повреждения файлов в процессе передачи.
 */
{
    fetch('https://example.com/resource.js', {
        integrity: 'sha256-abcdef1234567890'
    })
        .then(response => response.text())
        .then(data => {
            // Обработка загруженных данных
        })
        .catch(error => {
            // Обработка ошибок
        });
}

/**
 * keepalive
 * Эта установка указывает бразуеру выполнять запрос даже после того, как пользователь покидает страницу (Например нам надо отправить какую то статистику по сайту)
 */
{
    window.onunload = function() {
        fetch('/analytics', {
            method: 'POST',
            body: "statistics",
            keepalive: true
        });
    };
}