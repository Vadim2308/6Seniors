/**
 * Эти методы не являются частью спецификации JavaScript.
 * setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
 * setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
 */

/**
 * setTimeout
 * Синтаксис let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);
 *  func|code - Функция или строка(исторически сложилось что можно передать строку, но очень не рекомендуется) кода для выполнения.
 *  delay - задержка перед запуском в миллисекундах. Значение по умолчанию – 0.
 *  arg1, arg2… - аргументы, передаваемые в функцию
 */
{
    function sayHi(phrase, who) {
        alert( phrase + ', ' + who );
    }
    setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон

    // Строка
    setTimeout("alert('Привет')", 1000);
}

/**
 * clearTimeout
 * Вызов setTimeout возвращает «идентификатор таймера» (в node.js - объект), который можно использовать для отмены
 * Если таймаут больше не нужен (выполнился), обязательно нужно отменять, тк функция остается в памяти
 */
{
    let timerId = setTimeout(() => alert("ничего не происходит"), 1000);
    alert(timerId); // идентификатор таймера (например 5)
    clearTimeout(timerId);
    alert(timerId); // тот же идентификатор (5). После отмены переменная не меняется, просто в окружении браузера убирается колбек из таймаута
}

/**
 * setInterval
 * Тот же синтаксис как и у таймаута
 * let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
 * Для очистки использовать clearInterval(timerId)
 */

/**
 * Вложенный setTimeout
 * Вложенный setTimeout позволяет задать задержку между выполнениями более точно, чем setInterval.
 * Если функция ресурсоемка, то реальный промежуток между вызовами может быть намного меньше чем указан в интервале
 * Вложенный setTimeout гарантирует фиксированную задержку. (Это потому, что новый вызов планируется в конце предыдущего.) setInterval учитывает время на выполнение, он компенсирует задержку от исполнения функции
 */

/**
 * В браузере есть ограничение на частоту выполнения интервалов - после пяти вложенных таймеров интервал должен составлять не менее четырёх мс
 * То есть после 5 вызовов, последующие будут с интервалом минимум 4 мс
 */

{
    // Примеры:
    let timerId = setTimeout(function tick() {
        alert('tick');
        timerId = setTimeout(tick, 2000); // (*)
    }, 2000);

    function recursionTimeout() {
        setTimeout(function () {
            console.log('recursionTimeout');
            recursionTimeout();
        }, 5000);
    }
    recursionTimeout();
}

/**
 * setTimeout с нулевой задержкой. Это планирует вызов func настолько быстро, насколько это возможно.
 * setTimeout(func, 0) === setTimeout(func).
 */
{
    // Сначала выведет Привет, потом Мир
    setTimeout(() => alert("Мир"));
    alert("Привет");
}